<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.376">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>reply_to_reviewers_r3</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="reply_to_reviewers_R3_files/libs/clipboard/clipboard.min.js"></script>
<script src="reply_to_reviewers_R3_files/libs/quarto-html/quarto.js"></script>
<script src="reply_to_reviewers_R3_files/libs/quarto-html/popper.min.js"></script>
<script src="reply_to_reviewers_R3_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="reply_to_reviewers_R3_files/libs/quarto-html/anchor.min.js"></script>
<link href="reply_to_reviewers_R3_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="reply_to_reviewers_R3_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="reply_to_reviewers_R3_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="reply_to_reviewers_R3_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="reply_to_reviewers_R3_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">



<section id="reply-to-reviewer-1" class="level1">
<h1>Reply to Reviewer 1</h1>
<p>I have read the second revision of this manuscript and the authors’ responses to my last review. I think the authors have done an excellent job in responding to the points I raised in that review. Thus, I recommend acceptance after the authors address the very minor points that I noted while reading this version of the manuscript. Those points are as follows:</p>
<p></p>
<ul>
<li>Footnote 1 – change <code>saturated thickness'' to</code>aquifer thickness’’ to be consistent with usage elsewhere. Same for x-axis label on Figure C.2.</li>
</ul>
<p></p>
<ul>
<li>Line 110 – can you briefly describe how this ``accounting’’ is done?</li>
</ul>
<p></p>
<ul>
<li>Line 147 – <code>leading in'' should be</code>leading to’’.</li>
</ul>
<p></p>
<ul>
<li>Lines 282-283 – delete ``of the aquifer’’ - redundant.</li>
</ul>
<p></p>
<ul>
<li>Line 289 – <code>thickness'' should be</code>thicknesses’’.</li>
</ul>
<p></p>
<ul>
<li><p>Figure 7 – need a 200 m label for scale bar on soybean map. Are the blank areas in the aquifer in Texas and Oklahoma an indication that the aquifer is thin or that there is a lack of data? Please clarify.</p></li>
<li><p>Line 308 – <code>y'' should be</code>Y’’.</p></li>
</ul>
<p></p>
<ul>
<li><p>Lines 357-359 – delete sentence as it is repeated on lines 363-364 where it fits better.</p></li>
<li><p>Lines 401-402 – a recent paper in Agricultural Water Management addresses this issue in more detail (https://www.sciencedirect.com/science/article/pii/S0378377423002731).</p></li>
<li><p>Lines 410-413 – very awkward sentence – please rewrite.</p></li>
<li><p>Line 446 – delete ``across’’.</p></li>
</ul>
<p></p>
</section>
<section id="reply-to-reviewer-3" class="level1">
<h1>Reply to Reviewer 3</h1>
<p>The second round comments have been addressed convincingly. The discussion of the role of groundwater management policies in Appendix A is particularly useful addition, as it clarifies how the results presented here relate to the findings of analyses which focused more on policy factors. Ruling out regulations as a substantial causal factor based on the limited temporal overlap with the study period is coherent. The other edits implemented in response to the other comments have further improved the strength and accuracy of the presentation.</p>
<p>Two relatively minor points remain to be addressed, based on one of the responses and the data and code correction you mentioned:</p>
<ol type="1">
<li><p>I would recommend a minor addition regarding the response to my second round comment 5.b. You have pointed out that the claim of a significant yield decline in lines 77-78 is supported by Figure A.1 (and also A.2 for soybeans). Please add a reference to both figures in this sentence to clarify for readers where they can find evidence for the statistical significance.</p></li>
<li><p>The beginning of the response letter describes a code and data correction unrelated to the previous reviewer comments. ``[Counties] with only irrigated acres’’ were removed from the irrigation share regression. The immediate acknowledgement of this correction is appreciated. I trust that it was based on sensible considerations, though the rationale does not immediately become clear from the short statement, especially given that this does not seem to have been relevant previously. As you point out, the result changes due to this correction are quantitatively relatively minor (most visible in Figs. 3 and 4), and do not affect the qualitative findings or conclusions.</p></li>
</ol>
<p>I recommend, however, making sure that the correction, its rationale, and potential implications for the result interpretation are made clear to readers. Lines 347-348 state that “irrigated area share and average crop yield estimates use data only from counties that have both irrigated and rainfed production observations”. This statement covers the removal of fully irrigated counties, but could be clearer: Lines 348-350 mention the removal of ``solely rainfed’’ counties explicitly - mentioning this but not the removal of fully irrigated counties could be confusing to readers. Please include an explicit statement about the removal of fully irrigated counties to avoid confusion. Please also make clear whether this removal pertains to both regressions (as implied in lines 347) or just the irrigated share regression (the one highlighted in the letter).</p>
<p>Please also provide a short rationale, e.g.&nbsp;whether this is due to the model selected or substantive considerations. Finally, please clarify what this implies for the result interpretation. Fully irrigated county observations do not seem obviously irrelevant. The change in Fig. 3 results due to the correction is quantitatively minor but not irrelevant. It would, therefore, be helpful for readers to understand whether the exclusion of fully irrigated counties makes the results more accurate, or whether it creates a (necessary) bias.</p>
<p>Relatedly, it seems that in Fig. 7, some of the previously displayed counties in both the irrigated (color shaded) and rainfed (grey) categories are now missing. Did the exclusion of fully irrigated counties also affect which rainfed areas are represented? If so, please also clarify this link for the readers.</p>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        for (let i = 0; i < 2; i++) {
          container.appendChild(note.children[i].cloneNode(true));
        }
        return container.innerHTML
      } else {
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      return note.innerHTML;
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        console.log("RESIZE");
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>